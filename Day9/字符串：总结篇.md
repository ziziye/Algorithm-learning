# 字符串：总结篇
## 什么是字符串
字符串是若干字符组成的有限序列，也可以理解为是一个字符数组。<br>
在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。<br>

例如这段代码：<br>
```
char a[5] = "asd";
for (int i = 0; a[i] != '\0'; i++) {
}
```
在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。<br>

例如这段代码:<br>
```
string a = "asd";
for (int i = 0; i < a.size(); i++) {
}
```
那么vector< char > 和 string 又有什么区别呢？<br>
基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。<br>
所以想处理字符串，我们还是会定义一个string类型。<br>

## 打基础的时候，尽量不使用库函数，除非熟悉原理

## 双指针法
在344.反转字符串 (opens new window)，我们**使用双指针法实现了反转字符串的操作**，双指针法在数组，链表和字符串中很常用。<br>
接着在字符串：替换空格 (opens new window)，同样还是**使用双指针法在时间复杂度O(n)的情况下完成替换空格**。<br>
其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。<br>
那么针对数组删除操作的问题，其实在27. 移除元素 (opens new window)中就已经提到了使用双指针法进行移除操作。<br>

在151.翻转字符串里的单词 (opens new window)中我们使用O(n)的时间复杂度，完成了删除冗余空格。<br>
一些同学会使用for循环里调用库函数erase来移除元素，这其实是O(n^2)的操作，因为erase就是O(n)的操作，所以这也是典型的不知道库函数的时间复杂度，上来就用的案例了。<br>

## 反转系列
541. 反转字符串II (opens new window)中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。<br>
因为要找的也就是每2 * k 区间的起点，这样写程序会高效很多。<br>

在151.翻转字符串里的单词 (opens new window)中要求翻转字符串里的单词，这道题目可以说是综合考察了字符串的多种操作。是考察字符串的好题。<br>
这道题目通过 先整体反转再局部反转，实现了反转字符串里的单词。<br>
后来发现反转字符串还有一个牛逼的用处，就是达到左旋的效果。<br>

在字符串：反转个字符串还有这个用处？ (opens new window)中，我们通过先局部反转再整体反转达到了左旋的效果。<br>

## KMP
KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。<br>
KMP的精髓所在就是前缀表。<br>
**前缀表**：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。<br>

那么使用KMP可以解决两类经典问题：<br>
**匹配问题**：28. 实现 strStr()(opens new window)<br>
**重复子串问题**：459.重复的子字符串(opens new window)<br>
再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。<br>

**前缀**：指不包含最后一个字符的所有以第一个字符开头的连续子串。<br>
**后缀**：指不包含第一个字符的所有以最后一个字符结尾的连续子串。<br>

然后针对前缀表到底要不要减一，这其实是不同KMP实现的方式，我们在KMP精讲 (opens new window)中针对之前两个问题，分别给出了两个不同版本的的KMP实现。<br>
其中主要理解j=next[x]这一步最为关键！<br>

## 总结
字符串类类型的题目，往往想法比较简单，但是实现起来并不容易，复杂的字符串题目非常考验对代码的掌控能力。<br>
双指针法是字符串处理的常客。<br>

KMP算法是字符串查找最重要的算法，但彻底理解KMP并不容易，我们已经写了五篇KMP的文章，不断总结和完善，最终才把KMP讲清楚。<br>
好了字符串相关的算法知识就介绍到了这里了，明天开始新的征程，大家加油！<br>


