
# ä»£ç éšæƒ³å½•ç®—æ³•è®­ç»ƒè¥ç¬¬å››å¤©| 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€19.åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ã€142.ç¯å½¢é“¾è¡¨IIã€é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤
## Algorithm Learning Day 4 | 24. Swap Nodes in Pairs, 19. Remove Nth Node From End of List,142. Linked List Cycle II ,Interview question 02.07. Linked list intersection


## 24. Swap Nodes in Pairs
> é¢˜ç›®é“¾æ¥:(https://leetcode.com/problems/swap-nodes-in-pairs/)

### Question Description
ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚<br>
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

#### Example 1:
```
Input: head = [1,2,3,4]
Output: [2,1,4,3]
```
#### Example 2:
```
Input: head = []
Output: []
```
#### Constraints:
- The number of nodes in the list is in the range `[0, 100]`.
- `0 <= Node.val <= 100`

### Correct Code
```
var swapPairs = function(head) {
   let dummpy = new ListNode(0,head);
   let cur = dummpy;
   while(cur.next != null && cur.next.next != null)
   {
       let temp = cur.next;
       let temp1 = cur.next.next.next;
       cur.next = cur.next.next;
       cur.next.next = temp;
       temp.next = temp1;
       cur = cur.next.next;
   }
   return dummpy.next;
};
```
### Conclusion
1. é“¾è¡¨ä¸­å…ƒç´ äº¤æ¢å…¶å®å°±æ˜¯è™šæ‹Ÿå¤´ç»“ç‚¹`dummpy`çš„`cur`éå†èŠ‚ç‚¹æ”¹ä¸ºæŒ‡å‘ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œç„¶åç¬¬äºŒèŠ‚ç‚¹éœ€ç´§æ¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç„¶åç¬¬ä¸€ä¸ªèŠ‚ç‚¹å†ğŸ”—åˆ°ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹ã€‚<br>
  The exchange of elements in the linked list is actually that the virtual head node `dummy`'s `cur` traversal node is changed to point to the second node, and then the second node needs to be immediately connected to the first node, and then the first node goes to the third node.
2. ç”±äºç¬¬ä¸€ä¸ªèŠ‚ç‚¹å’Œç¬¬ä¸‰ä¸ªèŠ‚ç‚¹çš„è™šæ‹Ÿå¤´èŠ‚ç‚¹éƒ½æ”¹å˜äº†æŒ‡å‘ï¼Œå› æ­¤éœ€è¦è®¾ç«‹`temp`å’Œ`temp1`æš‚å­˜ç¬¬ä¸€ä¸ªå’Œç¬¬ä¸‰ä¸ªèŠ‚ç‚¹çš„åˆå§‹çŠ¶æ€ï¼Œæ–¹ä¾¿åç»­çš„èµ‹å€¼ã€‚<br>
  Since the virtual head nodes of the first node and the third node have changed their directions, `temp` and `temp1` need to be set up to temporarily store the initial states of the first and third nodes to facilitate subsequent assignments.
3. ä¹‹åï¼Œ`cur`éœ€è¦è·³åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹å¤„ã€‚<br>
  After that, `cur` needs to jump to the second node.
